import {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ChannelType,
  PermissionFlagsBits,
  TextChannel,
  ButtonInteraction,
  CommandInteraction,
  SlashCommandBuilder,
  REST,
  Routes,
} from "discord.js";

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
  ],
});

const TICKET_CATEGORY_NAME = "Tickets";
const STAFF_ROLE_NAME = "Staff";

// Store welcome channel per guild (in-memory, resets on restart)
const welcomeChannels = new Map<string, string>();

async function findOrCreateCategory(guild: any) {
  let category = guild.channels.cache.find(
    (c: any) => c.type === ChannelType.GuildCategory && c.name === TICKET_CATEGORY_NAME
  );

  if (!category) {
    category = await guild.channels.create({
      name: TICKET_CATEGORY_NAME,
      type: ChannelType.GuildCategory,
    });
  }

  return category;
}

async function createTicketChannel(interaction: ButtonInteraction) {
  const guild = interaction.guild;
  if (!guild) return;

  const user = interaction.user;
  const channelName = `ticket-${user.username.toLowerCase().replace(/[^a-z0-9]/g, "")}-${Date.now().toString(36)}`;

  const existingTicket = guild.channels.cache.find(
    (c: any) =>
      c.type === ChannelType.GuildText &&
      c.name.startsWith("ticket-") &&
      c.topic?.includes(user.id)
  );

  if (existingTicket) {
    await interaction.reply({
      content: `You already have an open ticket: <#${existingTicket.id}>`,
      ephemeral: true,
    });
    return;
  }

  await interaction.deferReply({ ephemeral: true });

  try {
    const category = await findOrCreateCategory(guild);
    
    const staffRole = guild.roles.cache.find((r: any) => r.name === STAFF_ROLE_NAME);

    const permissionOverwrites: any[] = [
      {
        id: guild.id,
        deny: [PermissionFlagsBits.ViewChannel],
      },
      {
        id: user.id,
        allow: [
          PermissionFlagsBits.ViewChannel,
          PermissionFlagsBits.SendMessages,
          PermissionFlagsBits.ReadMessageHistory,
          PermissionFlagsBits.AttachFiles,
          PermissionFlagsBits.EmbedLinks,
        ],
      },
      {
        id: client.user!.id,
        allow: [
          PermissionFlagsBits.ViewChannel,
          PermissionFlagsBits.SendMessages,
          PermissionFlagsBits.ManageChannels,
          PermissionFlagsBits.ManageMessages,
        ],
      },
    ];

    if (staffRole) {
      permissionOverwrites.push({
        id: staffRole.id,
        allow: [
          PermissionFlagsBits.ViewChannel,
          PermissionFlagsBits.SendMessages,
          PermissionFlagsBits.ReadMessageHistory,
          PermissionFlagsBits.AttachFiles,
          PermissionFlagsBits.ManageMessages,
        ],
      });
    }

    const ticketChannel = await guild.channels.create({
      name: channelName,
      type: ChannelType.GuildText,
      parent: category.id,
      topic: `Ticket opened by ${user.tag} (${user.id})`,
      permissionOverwrites,
    });

    const ticketEmbed = new EmbedBuilder()
      .setColor(0x5865f2)
      .setTitle("Middleman Request")
      .setDescription(
        `Hello ${user}, welcome to your middleman request!\n\nPlease provide the following information:`
      )
      .addFields(
        { name: "Requested By", value: `<@${user.id}>`, inline: true },
        { name: "Ticket ID", value: channelName, inline: true },
        { name: "\u200B", value: "\u200B" },
        { name: "What to provide:", value: 
          "**1.** What are you trading?\n" +
          "**2.** Who is the other party? (@ mention them)\n" +
          "**3.** What platform/game is this for?\n" +
          "**4.** Any additional details"
        }
      )
      .setTimestamp()
      .setFooter({ text: "A middleman will assist you shortly" });

    const closeButton = new ButtonBuilder()
      .setCustomId("close_ticket")
      .setLabel("Close Ticket")
      .setStyle(ButtonStyle.Danger)
      .setEmoji("üîí");

    const row = new ActionRowBuilder<ButtonBuilder>().addComponents(closeButton);

    await (ticketChannel as TextChannel).send({
      content: `<@${user.id}>`,
      embeds: [ticketEmbed],
      components: [row],
    });

    await interaction.editReply({
      content: `Your ticket has been created: <#${ticketChannel.id}>`,
    });
  } catch (error) {
    console.error("Error creating ticket:", error);
    await interaction.editReply({
      content: "There was an error creating your ticket. Please try again or contact an administrator.",
    });
  }
}

async function closeTicket(interaction: ButtonInteraction) {
  const channel = interaction.channel as TextChannel;
  
  if (!channel.name.startsWith("ticket-")) {
    await interaction.reply({
      content: "This command can only be used in ticket channels.",
      ephemeral: true,
    });
    return;
  }

  await interaction.deferReply();

  const closeEmbed = new EmbedBuilder()
    .setColor(0xed4245)
    .setTitle("Ticket Closed")
    .setDescription(`This ticket was closed by <@${interaction.user.id}>`)
    .setTimestamp();

  const deleteButton = new ButtonBuilder()
    .setCustomId("delete_ticket")
    .setLabel("Delete Ticket")
    .setStyle(ButtonStyle.Danger)
    .setEmoji("üóëÔ∏è");

  const reopenButton = new ButtonBuilder()
    .setCustomId("reopen_ticket")
    .setLabel("Reopen Ticket")
    .setStyle(ButtonStyle.Success)
    .setEmoji("üîì");

  const row = new ActionRowBuilder<ButtonBuilder>().addComponents(reopenButton, deleteButton);

  await interaction.editReply({
    embeds: [closeEmbed],
    components: [row],
  });

  const userId = channel.topic?.match(/\((\d+)\)/)?.[1];
  if (userId) {
    await channel.permissionOverwrites.edit(userId, {
      SendMessages: false,
    });
  }
}

async function reopenTicket(interaction: ButtonInteraction) {
  const channel = interaction.channel as TextChannel;

  await interaction.deferReply();

  const userId = channel.topic?.match(/\((\d+)\)/)?.[1];
  if (userId) {
    await channel.permissionOverwrites.edit(userId, {
      SendMessages: true,
    });
  }

  const reopenEmbed = new EmbedBuilder()
    .setColor(0x57f287)
    .setTitle("Ticket Reopened")
    .setDescription(`This ticket was reopened by <@${interaction.user.id}>`)
    .setTimestamp();

  const closeButton = new ButtonBuilder()
    .setCustomId("close_ticket")
    .setLabel("Close Ticket")
    .setStyle(ButtonStyle.Danger)
    .setEmoji("üîí");

  const row = new ActionRowBuilder<ButtonBuilder>().addComponents(closeButton);

  await interaction.editReply({
    embeds: [reopenEmbed],
    components: [row],
  });
}

async function deleteTicket(interaction: ButtonInteraction) {
  const channel = interaction.channel as TextChannel;

  await interaction.reply({
    content: "Deleting ticket in 5 seconds...",
  });

  setTimeout(async () => {
    try {
      await channel.delete();
    } catch (error) {
      console.error("Error deleting ticket channel:", error);
    }
  }, 5000);
}

async function sendTicketPanel(interaction: CommandInteraction) {
  const panelEmbed = new EmbedBuilder()
    .setColor(0x5865f2)
    .setTitle("Middleman Services")
    .setDescription(
      "Need a trusted middleman for your trade? Click the button below to request our middleman service.\n\n" +
      "**How it works:**\n" +
      "‚Ä¢ Create a ticket to request a middleman\n" +
      "‚Ä¢ Provide details about your trade (items, platform, other party)\n" +
      "‚Ä¢ A verified middleman will assist your transaction\n" +
      "‚Ä¢ Both parties confirm before items are exchanged\n\n" +
      "**Requirements:**\n" +
      "‚Ä¢ Both parties must be in this server\n" +
      "‚Ä¢ Provide clear trade details\n" +
      "‚Ä¢ Be patient while a middleman becomes available"
    )
    .setFooter({ text: "Safe and secure trades with verified middlemen" });

  const createButton = new ButtonBuilder()
    .setCustomId("create_ticket")
    .setLabel("Request Middleman")
    .setStyle(ButtonStyle.Primary)
    .setEmoji("ü§ù");

  const row = new ActionRowBuilder<ButtonBuilder>().addComponents(createButton);

  await interaction.reply({
    embeds: [panelEmbed],
    components: [row],
  });
}

client.once("ready", async () => {
  console.log(`Discord bot logged in as ${client.user?.tag}`);

  const commands = [
    new SlashCommandBuilder()
      .setName("ticket-panel")
      .setDescription("Send the ticket creation panel to this channel")
      .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),
    new SlashCommandBuilder()
      .setName("set-welcome")
      .setDescription("Set the welcome message channel")
      .addChannelOption(option =>
        option.setName("channel")
          .setDescription("The channel to send welcome messages to")
          .setRequired(true))
      .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),
    new SlashCommandBuilder()
      .setName("test-welcome")
      .setDescription("Test the welcome message")
      .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),
  ];

  const rest = new REST({ version: "10" }).setToken(process.env.DISCORD_BOT_TOKEN!);

  try {
    console.log("Registering slash commands...");
    await rest.put(Routes.applicationCommands(client.user!.id), {
      body: commands.map((cmd) => cmd.toJSON()),
    });
    console.log("Slash commands registered successfully!");
  } catch (error) {
    console.error("Error registering slash commands:", error);
  }
});

client.on("interactionCreate", async (interaction) => {
  if (interaction.isChatInputCommand()) {
    if (interaction.commandName === "ticket-panel") {
      await sendTicketPanel(interaction);
    }
    
    if (interaction.commandName === "set-welcome") {
      const channel = interaction.options.getChannel("channel");
      if (channel && interaction.guildId) {
        welcomeChannels.set(interaction.guildId, channel.id);
        await interaction.reply({
          content: `Welcome messages will now be sent to <#${channel.id}>`,
          ephemeral: true,
        });
      }
    }
    
    if (interaction.commandName === "test-welcome") {
      const guild = interaction.guild;
      const member = interaction.member;
      if (guild && member) {
        const welcomeChannelId = welcomeChannels.get(guild.id);
        if (!welcomeChannelId) {
          await interaction.reply({
            content: "No welcome channel set! Use `/set-welcome` first.",
            ephemeral: true,
          });
          return;
        }
        
        const welcomeChannel = guild.channels.cache.get(welcomeChannelId) as TextChannel;
        if (!welcomeChannel) {
          await interaction.reply({
            content: "Welcome channel not found!",
            ephemeral: true,
          });
          return;
        }
        
        const welcomeEmbed = new EmbedBuilder()
          .setColor(0x5865f2)
          .setTitle("Welcome!")
          .setDescription(`Welcome to **${guild.name}**, <@${interaction.user.id}>!`)
          .addFields(
            { name: "Member Count", value: `You are member #${guild.memberCount}`, inline: true }
          )
          .setThumbnail(interaction.user.displayAvatarURL({ size: 256 }))
          .setTimestamp()
          .setFooter({ text: "Enjoy your stay!" });
        
        await welcomeChannel.send({ embeds: [welcomeEmbed] });
        await interaction.reply({
          content: "Test welcome message sent!",
          ephemeral: true,
        });
      }
    }
  }

  if (interaction.isButton()) {
    switch (interaction.customId) {
      case "create_ticket":
        await createTicketChannel(interaction);
        break;
      case "close_ticket":
        await closeTicket(interaction);
        break;
      case "reopen_ticket":
        await reopenTicket(interaction);
        break;
      case "delete_ticket":
        await deleteTicket(interaction);
        break;
    }
  }
});

// Welcome message when a new member joins
client.on("guildMemberAdd", async (member) => {
  const welcomeChannelId = welcomeChannels.get(member.guild.id);
  if (!welcomeChannelId) return;
  
  const welcomeChannel = member.guild.channels.cache.get(welcomeChannelId) as TextChannel;
  if (!welcomeChannel) return;
  
  const welcomeEmbed = new EmbedBuilder()
    .setColor(0x5865f2)
    .setTitle("Welcome!")
    .setDescription(`Welcome to **${member.guild.name}**, <@${member.id}>!`)
    .addFields(
      { name: "Member Count", value: `You are member #${member.guild.memberCount}`, inline: true }
    )
    .setThumbnail(member.user.displayAvatarURL({ size: 256 }))
    .setTimestamp()
    .setFooter({ text: "Enjoy your stay!" });
  
  try {
    await welcomeChannel.send({ embeds: [welcomeEmbed] });
  } catch (error) {
    console.error("Error sending welcome message:", error);
  }
});

export function startDiscordBot() {
  const token = process.env.DISCORD_BOT_TOKEN;
  
  if (!token) {
    console.error("DISCORD_BOT_TOKEN is not set!");
    return;
  }

  client.login(token).catch((error) => {
    console.error("Failed to login to Discord:", error);
  });
}

export function getBotStatus() {
  return {
    online: client.isReady(),
    botName: client.user?.tag || null,
  };
}
